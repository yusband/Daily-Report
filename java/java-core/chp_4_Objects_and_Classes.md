##Java-Core-Ⅰ 
###第四章：对象与类


####oop
oop三大特性：封装、继承、抽象
oop需要考虑对象的几个特性：
- 对象的行为：可以对对象做什么？对象可以做什么？
- 对象的的状态：行为发生后，对象本身会发生哪些改变？
- 对象的标识：如何区分同一个类的不同实例？

####类之间有哪些关系？

- A use a B (dependence,耦合)
- A has a B 
- A is a B



####将类中的数据由public设置为private并提供setter/getter方法的好处：
- 封装
- 统一set/get数据的途径，当需要修改set/get的具体内容时，只需修改setter/getter方法本身即可(类似于取代hardcode)
- 可以在setter方法中加入检查当前值得逻辑


####语言有按值传递、按引用传递和按名传递，java中的方法接受参数是按值传递的：
即形参列表中接受并在方法内部使用的参数值，是实参的一个copy；即对参数值的任何操作不会改变实参本身。
当参数是对象变量时，方法获得是对象变量的copy，而copy也指向同一个对象实例，故而可以使用该copy对实例进行操作，从而产生"按引用传递"的错觉。这里按值传递体现在无法对传入的对象变量引用一个新的对象实例。

总结：
- 一个方法不能改变一个基本数据类型的参数
- 一个方法可以改变一个对象参数的状态
- 一个方法不能让一个对象参数引用一个新的对象实例


####重载：多个方法名称相同，参数不同。
注：返回类型不是方法签名的一部分——————不允许出现名称相同但是返回值不同的两个方法。

####无参构造器：
- 自定义的类没有提供任何一个构造器时，系统会自动提供一个空构造器(无参、初值为0or null)
- 自行提供了任何一个构造器时就不会生成上述的空构造器，故而初始化对象时不提供参数就被视为非法


####设计原则：
- 数据私有
- 数据初始化
- 并不是每条数据都要有getter/setter
- 当出现过多的基本数据类型的数据时，考虑封装进一个类
- 类的功能尽可能单一
- 命名要体现功能

###其他：

- 构造方法只和new关键字一起使用，不可能单独使用构造方法为一个对象"赋值"
- 不可变类：类中所有方法都不能改变其对象
- getter方法对封装的破坏(通过getter获得对象变量，并修改）/clone是如何解决的？
- 本地方法(native)可以修改java中使用final修饰的变量
- 注释：butterknife？
- 对static类型数据初始化较复杂时考虑使用static块
- 编译器不会检查包名(类之前)，故而如果一个类跟其他类没有联系而包名错误(并不在该包中)，编译会通过。





















